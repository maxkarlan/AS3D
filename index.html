<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Transparent Sphere with Cubes - Three.js</title>
    <script src="https://threejs.org/build/three.min.js"></script>
  </head>
<body>
  <script>
// Set up the scene, camera, and renderer
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(5, 0, 0); // move camera outside the sphere on one side
camera.lookAt(new THREE.Vector3(0, 0, 0)); // look at the center of the sphere
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Create the sphere geometry and material
const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.25 });
const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(sphereMesh);
    

    
// Create the inner sphere geometry and material
const innerSphereGeometry = new THREE.SphereGeometry(.5, 32, 32);
const innerSphereMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity:.4, wireframe: true });
const innerSphereMesh = new THREE.Mesh(innerSphereGeometry, innerSphereMaterial);
scene.add(innerSphereMesh);

// Add longitude lines to the sphere
for (let i = 0; i < 64; i++) {
  const points = [];
  for (let j = 0; j <= 32; j++) {
    const phi = (i / 64) * Math.PI * 2;
    const theta = (j / 32) * Math.PI - Math.PI / 2;
    const x = 2 * Math.cos(theta) * Math.cos(phi);
    const y = 2 * Math.sin(theta);
    const z = 2 * Math.cos(theta) * Math.sin(phi);
    points.push(new THREE.Vector3(x, y, z));
  }
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  let material;
  if (i % 2 === 0) {
    material = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.1, transparent: true });
  } else {
    material = new THREE.LineBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true });
  }
  const line = new THREE.Line(geometry, material);
  scene.add(line);
}
    
// Set up the camera
camera.position.set(0, 0, 1);
camera.zoom = 0.5;
camera.updateProjectionMatrix();

// Create 100 cubes with initial position and velocity set based on random angles around the sphere
let cubeGeometryIndex = 0;
const cubeGeometries = [
  new THREE.BoxGeometry(0.1, 0.1, 0.1),
  new THREE.TetrahedronGeometry(0.1),
  new THREE.OctahedronGeometry(0.1),
  new THREE.DodecahedronGeometry(0.1),
  new THREE.IcosahedronGeometry(0.1)
];
const cubes = [];
for (let i = 0; i < 30; i++) {
  // Set a random shade of the ocean for the cube material
  const hue = 0.55;
  const saturation = 1;
  const lightness = Math.random();
  const color = new THREE.Color().setHSL(hue, saturation, lightness);
  const cubeMaterial = new THREE.MeshBasicMaterial({ color: color });
  
  const cubeMesh = new THREE.Mesh(cubeGeometries[cubeGeometryIndex], cubeMaterial);
  cubeMesh.userData.geometryIndex = cubeGeometryIndex;
  
  // Set the initial position of the cube based on a random angle around the sphere
  const phi = Math.random() * Math.PI * 2; // Random angle around the sphere
  const theta = Math.random() * Math.PI - Math.PI / 2; // Random angle from the top of the sphere
  const radius = 2; // Distance from the center of the sphere
  const x = radius * Math.cos(theta) * Math.cos(phi);
  const y = radius * Math.sin(theta);
  const z = radius * Math.cos(theta) * Math.sin(phi);
  cubeMesh.position.set(x, y, z);
  
  // Set the initial velocity of the cube based on a random angle around the sphere
  const velocityTheta = Math.random() * Math.PI * 2; // Random angle around the sphere
  const velocityPhi = Math.random() * Math.PI - Math.PI / 2; // Random angle from the top of the sphere
  const velocityX = Math.sin(velocityTheta) * Math.cos(velocityPhi);
  const velocityY = Math.sin(velocityPhi);
  const velocityZ = Math.cos(velocityTheta) * Math.cos(velocityPhi);
  const velocity = new THREE.Vector3(velocityX, velocityY, velocityZ).normalize().multiplyScalar(0.03);
  cubeMesh.userData.velocity = velocity;
  
  cubes.push(cubeMesh);
  scene.add(cubeMesh);
}


// Use a timer to change the shape of each cube every 3 seconds
setInterval(() => {
  cubes.forEach(cube => {
    cubeGeometryIndex = (cube.userData.geometryIndex + 1) % cubeGeometries.length;
    cube.geometry = cubeGeometries[cubeGeometryIndex];
    cube.userData.geometryIndex = cubeGeometryIndex;
  });
}, 3000);
    
// Use the onBeforeRender event to update the cube positions
function updateCubes() {
  cubes.forEach(cube => {
    cube.position.add(cube.userData.velocity);
    
    // Check if the cube is off the surface of the sphere and reflect it back onto the surface
    const distance = cube.position.distanceTo(sphereMesh.position);
    if (distance > 2) {
      const reflection = new THREE.Vector3().subVectors(cube.position, sphereMesh.position).normalize();
      cube.userData.velocity.reflect(reflection);
    }
  });
}

// Render the scene and update the cube positions on each frame
function render() {
  updateCubes();
  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

window.addEventListener('resize', onWindowResize);

// Use the mousemove event to update the camera rotation
document.addEventListener('mousemove', event => {
  const mouseX = event.clientX / window.innerWidth;
  const mouseY = event.clientY / window.innerHeight;
  camera.rotation.y = (mouseX - 0.5) * Math.PI;
  camera.rotation.x = (mouseY - 0.5) * Math.PI;
});
    

// Use the wheel event to zoom the camera in and out
document.addEventListener('wheel', event => {
  camera.zoom += event.deltaY * 0.001;
  camera.zoom = Math.max(0.1, Math.min(camera.zoom, 10));
  camera.updateProjectionMatrix();
});


renderer.setAnimationLoop(render);

  </script>
</body>
</html>