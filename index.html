<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Transparent Sphere with Cubes - Three.js</title>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script type="x-shader/x-vertex" id="vertexShader">
      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>
        <script type="x-shader/x-fragment" id="fragmentShader">
      uniform float time;

      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
      }

      float noise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);

        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));

        vec2 u = f * f * (3.0 - 2.0 * f);

        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
      }

      void main() {
        vec3 color = vec3(1.0);

        float noiseValue = 1.0;

        float frequency = 2.0;
        float amplitude = 1.0;
        float maxAmplitude = 1.0;

        for (int i = 0; i < 4; i++) {
          noiseValue += amplitude * noise(vec2(frequency * gl_FragCoord.xy / 100.0 + time * 0.2));
          maxAmplitude += amplitude;
          amplitude *= 0.5;
          frequency *= 2.0;
        }

        noiseValue /= maxAmplitude;

        color = mix(vec3(1.0, 0.0, 0.0), vec3(.2, 0, 0.5), noiseValue);

        gl_FragColor = vec4(color, 1.0);
      }
    </script>
  </head>
<body>
  <script>
// Import the noisejs library
// import { Noise } from 'noisejs';    
    
// Set up the scene, camera, and renderer
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(5, 0, 0); // move camera outside the sphere on one side
camera.lookAt(new THREE.Vector3(0, 0, 0)); // look at the center of the sphere
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
// Create a new point light
var pointLight = new THREE.PointLight(0xffffff, 1, 100);
pointLight.position.set(0, 10, 10);

// Add the point light to the scene
scene.add(pointLight);

// Create the sphere geometry and material
const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.25 });
const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(sphereMesh);
    
// Create the inner sphere geometry and material
const innerSphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
const innerSphereMaterial = new THREE.MeshBasicMaterial({ color: 0xEE82EE, transparent: true, opacity:0.4, wireframe: true });
const innerSphereMesh = new THREE.Mesh(innerSphereGeometry, innerSphereMaterial);
scene.add(innerSphereMesh);
    
// Create the third, smallest sphere geometry and material
const smallestSphereGeometry = new THREE.SphereGeometry(0.25, 32, 32);
 // Create shader material with Perlin noise
      var perlinMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { type: 'f', value: 0.0 }
        },
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent
      });

      // Create sphere mesh with shader material
      var smallestSphereMesh = new THREE.Mesh(smallestSphereGeometry, perlinMaterial);
    
          // Add sphere to scene
      scene.add(smallestSphereMesh);
    
// Create 50 Icosahedrons that orbit around the middle sphere
const numIcosahedrons = 50;
const icosahedronGeometry = new THREE.IcosahedronGeometry(0.05, 1);
const icosahedronMaterial = new THREE.MeshPhongMaterial({ color: 0xff00ff, shininess: 100 });
const icosahedrons = [];
for (let i = 0; i < numIcosahedrons; i++) {
  const icosahedronMesh = new THREE.Mesh(icosahedronGeometry, icosahedronMaterial);
  // Calculate a random longitude and latitude for the Icosahedron's orbit
  const longitude = Math.random() * Math.PI * 2;
  const latitude = Math.random() * Math.PI * 2;
  const radius = .5;
  // Calculate the position of the Icosahedron on its orbit
  const x = radius * Math.sin(latitude) * Math.cos(longitude);
  const y = radius * Math.sin(latitude) * Math.sin(longitude);
  const z = radius * Math.cos(latitude);
  icosahedronMesh.position.set(x, y, z);
  scene.add(icosahedronMesh);
  // Store the Icosahedron's initial position, longitude, latitude, and radius
  icosahedrons.push({
    mesh: icosahedronMesh,
    initialPosition: icosahedronMesh.position.clone(),
    longitude: longitude,
    latitude: latitude,
    radius: radius,
  });
}
    
  
// Add longitude lines to the sphere
for (let i = 0; i < 64; i++) {
  const points = [];
  for (let j = 0; j <= 32; j++) {
    const phi = (i / 64) * Math.PI * 2;
    const theta = (j / 32) * Math.PI - Math.PI / 2;
    const x = 2 * Math.cos(theta) * Math.cos(phi);
    const y = 2 * Math.sin(theta);
    const z = 2 * Math.cos(theta) * Math.sin(phi);
    points.push(new THREE.Vector3(x, y, z));
  }
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  let material;
  if (i % 2 === 0) {
    material = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.1, transparent: true });
  } else {
    material = new THREE.LineBasicMaterial({ color: 0x008080, opacity: 0.5, transparent: true });
  }
  const line = new THREE.Line(geometry, material);
  scene.add(line);
}
    
// Set up the camera
camera.position.set(0, 0, 1);
camera.zoom = 0.5;
camera.updateProjectionMatrix();

// Create 100 cubes with initial position and velocity set based on random angles around the sphere
let cubeGeometryIndex = 0;
const cubeGeometries = [
  new THREE.BoxGeometry(0.1, 0.1, 0.1),
  new THREE.TetrahedronGeometry(0.1),
  new THREE.OctahedronGeometry(0.1),
  new THREE.DodecahedronGeometry(0.1),
  new THREE.IcosahedronGeometry(0.1)
];
// const noise = new Noise();
const cubes = [];
for (let i = 0; i < 50; i++) {
  // Set a random shade of the ocean for the cube material
  const hue = 0.55;
  const saturation = 1;
  const lightness = Math.random();
  const color = new THREE.Color().setHSL(hue, saturation, lightness);
  const cubeMaterial = new THREE.MeshBasicMaterial({ color: color });
  
  const cubeMesh = new THREE.Mesh(cubeGeometries[cubeGeometryIndex], cubeMaterial);
  cubeMesh.userData.geometryIndex = cubeGeometryIndex;
  
  // Set the initial position of the cube based on a random angle around the sphere
  const phi = Math.random() * Math.PI * 2; // Random angle around the sphere
  const theta = Math.random() * Math.PI - Math.PI / 2; // Random angle from the top of the sphere
  const radius = 2; // Distance from the center of the sphere
  const x = radius * Math.cos(theta) * Math.cos(phi);
  const y = radius * Math.sin(theta);
  const z = radius * Math.cos(theta) * Math.sin(phi);
  cubeMesh.position.set(x, y, z);
  
  // Set the initial velocity of the cube based on a random angle around the sphere
  const velocityTheta = Math.random() * Math.PI * 2; // Random angle around the sphere
  const velocityPhi = Math.random() * Math.PI - Math.PI / 2; // Random angle from the top of the sphere
  const velocityX = Math.sin(velocityTheta) * Math.cos(velocityPhi);
  const velocityY = Math.sin(velocityPhi);
  const velocityZ = Math.cos(velocityTheta) * Math.cos(velocityPhi);
  const velocity = new THREE.Vector3(velocityX, velocityY, velocityZ).normalize().multiplyScalar(0.015);
  cubeMesh.userData.velocity = velocity;
  
  cubes.push(cubeMesh);
  scene.add(cubeMesh);
}


// Use a timer to change the shape of each cube every 3 seconds
setInterval(() => {
  cubes.forEach(cube => {
    cubeGeometryIndex = (cube.userData.geometryIndex + 1) % cubeGeometries.length;
    cube.geometry = cubeGeometries[cubeGeometryIndex];
    cube.userData.geometryIndex = cubeGeometryIndex;
  });
}, 3000);
    
// Use the onBeforeRender event to update the cube positions
function updateCubes() {
  cubes.forEach(cube => {
    cube.position.add(cube.userData.velocity);
    
    // Check if the cube is off the surface of the sphere and reflect it back onto the surface
    const distance = cube.position.distanceTo(sphereMesh.position);
    if (distance > 2) {
      const reflection = new THREE.Vector3().subVectors(cube.position, sphereMesh.position).normalize();
      cube.userData.velocity.reflect(reflection);
    }
  });
}
    
      // Animate the Perlin noise by updating the time uniform in the material
      function animate() {
        requestAnimationFrame(animate);
        perlinMaterial.uniforms.time.value += 0.1;
        renderer.render(scene, camera);
      }
    
// Set the initial camera position and movement speed
let xSpeed = 0;
let zSpeed = 0;
const movementSpeed = 0.1;
    
// Create a new variable to keep track of the mouse position
var mouse = new THREE.Vector2();

// Add an event listener for keydown events
document.addEventListener('keydown', (event) => {
  switch (event.key) {
    case 'w':
      zSpeed = -movementSpeed;
      break;
    case 'a':
      xSpeed = -movementSpeed;
      break;
    case 's':
      zSpeed = movementSpeed;
      break;
    case 'd':
      xSpeed = movementSpeed;
      break;
  }
});

// Add an event listener for keyup events
document.addEventListener('keyup', (event) => {
  switch (event.key) {
    case 'w':
    case 's':
      zSpeed = 0;
      break;
    case 'a':
    case 'd':
      xSpeed = 0;
      break;
  }
});

// Render the scene and update the cube positions on each frame
function render() {
  updateCubes();
   // Update the positions of the Icosahedrons
  for (let i = 0; i < numIcosahedrons; i++) {
    const icosahedron = icosahedrons[i];
    // Increment the Icosahedron's longitude and latitude angles
    icosahedron.longitude += 0.0001 * i;
    icosahedron.latitude += 0.0001 * (i + 1);
    // Calculate the new position of the Icosahedron on its orbit
    const x = icosahedron.radius * Math.sin(icosahedron.latitude) * Math.cos(icosahedron.longitude);
    const y = icosahedron.radius * Math.sin(icosahedron.latitude) * Math.sin(icosahedron.longitude);
    const z = icosahedron.radius * Math.cos(icosahedron.latitude);
    // Update the Icosahedron's position
    icosahedron.mesh.position.set(x, y, z);
  }
  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

window.addEventListener('resize', onWindowResize);

// Use the mousemove event to update the camera rotation
document.addEventListener('mousemove', event => {
  const mouseX = event.clientX / window.innerWidth;
  const mouseY = event.clientY / window.innerHeight;
  camera.rotation.y = (mouseX - 0.5) * Math.PI;
  camera.rotation.x = (mouseY - 0.5) * Math.PI;
});
    

// Use the wheel event to zoom the camera in and out
document.addEventListener('wheel', event => {
  camera.zoom += event.deltaY * 0.001;
  camera.zoom = Math.max(0.1, Math.min(camera.zoom, 10));
  camera.updateProjectionMatrix();
});

renderer.setAnimationLoop(render);
    
// Render the scene on each animation frame
function animate() {
  requestAnimationFrame(animate);

  // Get the camera's current orientation as a unit vector
  const orientation = new THREE.Vector3(0, 0, -1);
  orientation.applyQuaternion(camera.quaternion);

  // Update the camera position based on the current movement speed and orientation
  const cameraSpeed = new THREE.Vector3(xSpeed, 0, zSpeed);
  cameraSpeed.applyQuaternion(camera.quaternion);
  camera.position.add(cameraSpeed);

  renderer.render(scene, camera);
}
animate();

  </script>
</body>
</html>